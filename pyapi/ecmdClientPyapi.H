#ifndef _ecmdClientPyapi_H
#define _ecmdClientPyapi_H
// Copyright **********************************************************
//
//                                                                      
// IBM Confidential                                                     
// OCO Source Materials                                                 
// 9400 Licensed Internal Code                                          
// (C) COPYRIGHT IBM CORP. 2003
//                                                                      
// The source code for this program is not published or otherwise       
// divested of its trade secrets, irrespective of what has been         
// deposited with the U.S. Copyright Office.                             
//                                                                      
// End Copyright ******************************************************
/* $Header$ */


//--------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------
#include <string>

#include <ecmdDefines.H>
#include <ecmdStructs.H>
#include <ecmdDataBuffer.H>

/**
 * @file ecmdClientPyapi.H
 * @brief eCMD Python API
 * Usage : 
   <pre>
 import ecmd
   </pre>

*/

/** @name Load/Unload Functions */
//@{

/**
   @brief Initialize the eCMD DLL
   @retval 0 if successful load  1 if unsuccessful
   @param i_dllName Full path and filename of the eCMD Dll to load
   @param i_clientVersion Comma seperated list of eCMD Python API major numbers this script supports, see details
   @pre ecmdClientPyapi constructor must have been called
   
   - initializes the eCMD Dll.<br>

   VERSIONS :<br>
   eCMD at times has to make changes to add/remove functionality and parameters to functions.  This could cause
   incompatability in your script if you used functions that have changed.  The i_clientVersion string is used
   to tell eCMD which major releases you support such that your script will not continue execution if it encounters
   a version that is either not known about or not supported.  This is similar to how the eCMD C-Api works except in
   Python you can support multiple versions with one script as long as the changes that were made between the versions
   do not affect your script.

   USAGE :<br>
   if (ecmdLoadDll("","ver13,ver14")) { die "Fatal errors initializing DLL"; }<br>

*/
uint32_t ecmdLoadDll(const char * i_dllName, const char * i_clientVersion);

/**
   @brief Pass any unknown command line paramaters to the DLL for processing (ex. -p#, Cronus -debug)
   @retval ECMD_SUCCESS if successful
   @retval nonzero if unsuccessful
   @param io_argv Passed from Command line Arguments
   @pre initDll must have been called
   @post Global options (ex. -p#, -c#) will be removed from arg list
   @see initDll

   - argv gets passed to the eCMD DLL.<br>
   - Global options such as -p#, -c# will be parsed out.<br>
   - Target flags can be queried later with functions like ecmdQuerySelected<br>
   NOTE : This function does not affect ring caching<br>

   USAGE :<br>
   ecmdCommandArgs(sys.argv)<br>

*/
uint32_t ecmdCommandArgs(char** io_argv); 
//@}


/** @name Command Line Parsing Functions */
//@{

/**
 * @brief Iterates over argv, looking for given option string, removes it if found
 * @retval 1 if option found, 0 otherwise
 * @param io_argv Array of strings passed in from command line
 * @param i_option Option to look for
 * @see ecmdParseOptionWithArgs
 
   USAGE :<br>
   ecmdParseOption(sys.argv, "-h")<br>
 */
bool ecmdParseOption (char ** io_argv, const char * i_option);

/**
 * @brief Iterates over argv, looking for given option string, removes it if found
 * @retval Value of option arg if found, NULL otherwise
 * @param io_argv Array of strings passed in from command line
 * @param i_option Option to look for
 * @see ecmdParseOptionWithArgs
 
   USAGE :<br>
   threads = ecmdParseOptionWithArgs(sys.argv, "-t")<br>
*/
char * ecmdParseOptionWithArgs(char ** io_argv, const char * i_option);

//@}



/*** -------------------------------------- ***/
/*** The following is doxygen documentation ***/
/*** -------------------------------------- ***/


/**
 * @mainpage

<br>

@section pyapi eCMD Python API
 In addition to a C/C++ API, eCMD provides a Python API.  It is generated by running SWIG against the C-API
<br><br>
 The API interface is implemented as an "ecmd" object.  The ecmd class has methods to initialize eCMD, use the ecmdDataBuffer and make standard function calls. 
<br>
This Document Last Approved: July 23rd, 2014
 <br>
 <hr>
 @section files Related Information
  NOTE : Some of this documentation may look like C/C++ files/headers but that is a side effect of the tool we are using to generated the Python API and documentation.  Treat as Python functions and especially look at any usage information associated with each function description

 <ul>
 <li>ecmdClientPyapi.H</li>
 <li>ecmdDataBuffer</li>
 <li>ecmdStructs.H</li>
 <li>ecmdUtils.H</li>
 <li>ecmdSharedUtils.H</li>
 </ul>

<hr>
@section ext eCMD Extensions
These are extensions to the core eCMD interface, not all eCMD Plugins support these extensions.<br>

\if ECMD_CMD_EXTENSION_SUPPORT
@subsection cmd CMD Command line Extension
This extension provides interfaces to call command line functions and have formatted data displayed to stdout or returned to the caller.  It supports command from the core command line and also all extensions.<br>

Include files :
<ul>
<li> cmdClientPyapi.H</li>
<li> cmdStructs.H</li>
</ul>
\endif

\if ECMD_CIP_EXTENSION_SUPPORT
@subsection cip CIP (Cronus/IP) Extension
This extension provides interfaces to start/stop processor instructions and breakpoint handling.<br>

Include files :
<ul>
<li> cipClientPyapi.H </li>
<li> cipStructs.H</li>
</ul>
\endif

\if ECMD_GIP_EXTENSION_SUPPORT
@subsection gip GIP GFW IP-Series Extension
This extension provides IP Series GFW only interfaces.<br>

Include files :
<ul>
<li> gipClientPyapi.H </li>
<li> gipStructs.H</li>
</ul>
\endif

\if ECMD_CRO_EXTENSION_SUPPORT
@subsection cronus Cronus Extension
This extension provides Cronus only interfaces.<br>

Include files :
<ul>
<li> croClientPyapi.H </li>
<li> croStructs.H</li>
</ul>
\endif

\if ECMD_ZSE_EXTENSION_SUPPORT
@subsection zse Z Series Extension
This extension provides Z-Series only interfaces.<br>

Include files :
<ul>
<li> zseClientPyapi.H </li>
<li> zseStructs.H</li>
</ul>
\endif

\if ECMD_EIP_EXTENSION_SUPPORT
@subsection eip EIP (Eclipz I/P) Extension
This extension provides Eclipz only interfaces.<br>

Include files :
<ul>
<li> eipClientPyapi.H </li>
<li> eipStructs.H</li>
</ul>
\endif

\if ECMD_AIP_EXTENSION_SUPPORT
@subsection aip AIP (Apollo I/P) Extension
This extension provides Apollo only interfaces.<br>

Include files :
<ul>
<li> aipClientPyapi.H </li>
<li> aipStructs.H</li>
</ul>
\endif

\if ECMD_SCAND_EXTENSION_SUPPORT
@subsection scand ScanD Extension
This extension provides ScanD only interfaces.<br>

Include files :
<ul>
<li> scandClientPyapi.H</li>
<li> scandStructs.H</li>
</ul>
\endif

\if ECMD_BML_EXTENSION_SUPPORT
@subsection bml BML Extension
This extension provides BML only interfaces and is only available running eCMD in a BML environment.<br>

Include files :
<ul>
<li> bmlClientPyapi.H </li>
<li> bmlStructs.H</li>
</ul>
\endif

\if ECMD_MBO_EXTENSION_SUPPORT
@subsection mbo MBO (Mambo) Extension
This extension provides Mambo Simulator only interfaces.<br>

Include files :
<ul>
<li> mboClientPyapi.H </li>
<li> mboStructs.H</li>
</ul>
\endif

\if ECMD_FAPI_EXTENSION_SUPPORT
@subsection fapi FAPI (Hardware Procedure Framework) Extension
In Python only extension intialization is provided
Include files :
<ul>
<li> fapiClientPyapi.H</li>
</ul>
\endif

<br><br>

 <hr>
 @section pyv Python Version
 eCMD Scripts need at least Python 2 

 <pre>
 #!/usr/bin/python 

 import ecmd

 # Initialize the Plugin - has to be first thing done
 # Here we pass in that we know this script supports eCMD Releases 1.x if we know we support more we could pass like "ver1,ver2"
 if (ecmdLoadDll("", "ver1")):
    print("ERROR: Fatal errors initializing DLL")
    return 1
 </pre>


 <br>
 <hr>
 @section extinit Using eCMD Python Extensions
 If you need functionality from an eCMD Extension that provides the Python API, it is initialized like below.  This is a 'cip'
extension example but all extensions work the same way just replace the prefix with the extension of choice.
<br>
<pre>

 # Initialize the Plugin - has to be first thing done 
 if (ecmdLoadDll("", "ver1")):
    print("ERROR: Fatal errors initializing DLL")
    return 1

 # Now initialize the extension as well
 if (cipInitExtension("ver1")):
    print("Fatal errors initializing CIP Extension")
    return 1

</pre>

 <br>
 <hr>
 @section dform Data Passing
 @subsection ecmdDataBuffer ecmdDataBuffer's
 Data is passed between the client Python script and the eCMD shared object in the form of the same ecmdDataBuffer that is part of the C-Api.  The function set is the identical.  For additional documentation on the ecmdDataBuffer see the C/C++ Api Documentation.
<br>
Here is an example usage of the ecmdDataBuffer:
<pre>

  # Create a pointer to an DataBuffer class
  my data = ecmd.ecmdDataBuffer()

  # Set the size of my buffer
  data.setBitLength(32)

  # Set the first word of data in this class
  data.setWord(0,0xFEEDBEEF)

  # Read data from the chip
  rc = 0
  rc = ecmd.getRing(target, "idreg", data);

  # What is in the first word
  print("Data : %.08X" % data.getWord(0))

  # Change the value
  data.setWord(0,0xAAAA5555)
  print("Data : %.08X" % data.getWord(0))

  # Write my new value to the chip
  rc = ecmd.putRing(target, "idreg", data)
</pre>

 <b>WARNING: </b> The '=' operator DOES NOT work between ecmdDataBuffer's or any other structure like you would expect it to in C. See 'Python API Usage' below
<br>
 <hr>
@section target Chip/Object targeting
Python functions use the same ecmdChipTarget structure as the C-Api.

<pre>
  target = ecmd.ecmdChipTarget()
  target.chipType = "pu"
  target.cage = 0
  target.node = 0
  target.slot = 0
  target.pos = 1
  target.core = 0

  rc = ecmd.putRing(target, "idreg", data)

</pre>
 <b>WARNING: </b> The '=' operator DOES NOT work between ecmdChipTarget's or any other structure like you would expect it to in C. See 'Python API Usage' below

<br><br>
 <hr>
 @section pythonuse Pyton API Usage

 The following should be observed when using the Python API.

 <ol>
 <li> The ecmdLoadDll() function should ALWAYS be the first function called.</li>
 <li> The ecmdUnloadDll() function should be called just before script exit</li>
 </ol>

<br>
 @subsection operator The '=' operator
 <b>WARNING:</b> Because of the behavior of Python the following statements results in two variables pointing to the same data:
<pre>
  data1 = ecmd.ecmdDataBuffer()
  data1.setBitLength(32)
  data1.setWord(0,0xFEEDBEEF)

  # Use the = operator
  data2 = data1

  print("Data 1 : %.08X" % data1.getWord(0))        # This will echo 'Data 1 : FEEDBEEF'
  print("Data 2 : %.08X" % data2.getWord(0))        # This will echo 'Data 2 : FEEDBEEF'

  # Now just set Data 2
  data2.setWord(0,0xAAAA5555)

  print("Data 1 : %.08X", data1.getWord(0))        # This will echo 'Data 1 : AAAA5555'
  print("Data 2 : %.08X", data2.getWord(0))        # This will echo 'Data 2 : AAAA5555'
</pre>  
 NOTE : Since both data1 and data2 point to the same memory space when one is modified they are both modified.  This behavior is the same for the ecmdDataBuffer and all eCMD structures found in ecmdStructs.H

 To work around this problem you need to copy the contents of a structure manually :
 <ul>
 <li> For ecmdDataBuffer : data1.copy(data2)
 <li> For Structures : target2.cage = target.cage
 </ul>

 <br>
 <hr>
 @section pythonscript Example Python Script

 Please see the eCMD web page under 'Use eCMD' for an example Python script at : http://rhea.rch.stglabs.ibm.com/eCMD/


*/


#endif /* _ecmdClientPyapi_H */
