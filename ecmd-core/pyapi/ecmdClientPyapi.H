//IBM_PROLOG_BEGIN_TAG
/* 
 * Copyright 2003,2016 IBM International Business Machines Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//IBM_PROLOG_END_TAG

#ifndef _ecmdClientPyapi_H
#define _ecmdClientPyapi_H


//--------------------------------------------------------------------
// Includes
//--------------------------------------------------------------------
#include <string>

#include <ecmdDefines.H>
#include <ecmdStructs.H>
#include <ecmdDataBuffer.H>

/**
 * @file ecmdClientPyapi.H
 * @brief eCMD Python API
 * Usage : 
   <pre>
 import ecmd
   </pre>

*/

/** @name Load/Unload Functions */
//@{

/**
   @brief Initialize the eCMD DLL
   @retval 0 if successful load  1 if unsuccessful
   @param i_dllName Full path and filename of the eCMD Dll to load
   @param i_clientVersion Comma seperated list of eCMD Python API major numbers this script supports, see details
   @pre ecmdClientPyapi constructor must have been called
   
   - initializes the eCMD Dll.<br>

   VERSIONS :<br>
   eCMD at times has to make changes to add/remove functionality and parameters to functions.  This could cause
   incompatability in your script if you used functions that have changed.  The i_clientVersion string is used
   to tell eCMD which major releases you support such that your script will not continue execution if it encounters
   a version that is either not known about or not supported.  This is similar to how the eCMD C-Api works except in
   Python you can support multiple versions with one script as long as the changes that were made between the versions
   do not affect your script.

   USAGE :<br>
   if (ecmd.ecmdLoadDll("","ver13,ver14")) { die "Fatal errors initializing DLL"; }<br>

*/
uint32_t ecmdLoadDll(const char * i_dllName, const char * i_clientVersion);

/**
   @brief Pass any unknown command line paramaters to the DLL for processing (ex. -p#, Cronus -debug)
   @retval ECMD_SUCCESS if successful
   @retval nonzero if unsuccessful
   @param io_argv Passed from Command line Arguments
   @pre initDll must have been called
   @post Global options (ex. -p#, -c#) will be removed from arg list
   @see initDll

   - argv gets passed to the eCMD DLL.<br>
   - Global options such as -p#, -c# will be parsed out.<br>
   - Target flags can be queried later with functions like ecmdQuerySelected<br>
   NOTE : This function does not affect ring caching<br>

   USAGE :<br>
   ecmd.ecmdCommandArgs(sys.argv)<br>

*/
uint32_t ecmdCommandArgs(char** io_argv); 
//@}


/** @name Command Line Parsing Functions */
//@{

/**
 * @brief Iterates over argv, looking for given option string, removes it if found
 * @retval 1 if option found, 0 otherwise
 * @param io_argv Array of strings passed in from command line
 * @param i_option Option to look for
 * @see ecmdParseOptionWithArgs
 
   USAGE :<br>
   ecmd.ecmdParseOption(sys.argv, "-h")<br>
 */
bool ecmdParseOption (char ** io_argv, const char * i_option);

/**
 * @brief Iterates over argv, looking for given option string, removes it if found
 * @retval Value of option arg if found, NULL otherwise
 * @param io_argv Array of strings passed in from command line
 * @param i_option Option to look for
 * @see ecmdParseOptionWithArgs
 
   USAGE :<br>
   threads = ecmd.ecmdParseOptionWithArgs(sys.argv, "-t")<br>
*/
char * ecmdParseOptionWithArgs(char ** io_argv, const char * i_option);

//@}



/*** -------------------------------------- ***/
/*** The following is doxygen documentation ***/
/*** -------------------------------------- ***/


/**
 * @mainpage

<br>

@section pyapi eCMD Python API
 In addition to a C/C++ API, eCMD provides a Python API.  It is generated by running SWIG against the C-API
<br><br>
 The API interface is implemented as an "ecmd" object.  The ecmd class has methods to initialize eCMD, use the ecmdDataBuffer and make standard function calls. 
<br>
 <hr>
 @section files Related Information
  NOTE : Some of this documentation may look like C/C++ files/headers but that is a side effect of the tool we are using to generated the Python API and documentation.  Treat as Python functions and especially look at any usage information associated with each function description.

 <b>IMPORTANT NOTE: Any function parameters that are listed as by-reference outputs, that aren't eCMD structures (e.g. std::string &, uint32_t &, etc.) are returned as a python tuple, along with the return code.  The return code is always the first element of the tuple.  See "Python tuple return example" in Example Python Script below.</b>

 <ul>
 <li>ecmdClientPyapi.H</li>
 <li>ecmdDataBuffer</li>
 <li>ecmdStructs.H</li>
 <li>ecmdUtils.H</li>
 <li>ecmdSharedUtils.H</li>
 </ul>

<hr>
@section ext eCMD Extensions
Check ecmdExtPyapi.H to see the supported extensions and how to use them

 <hr>
 @section pyv Python Version
 eCMD Scripts need at least Python 2 

 <pre>
 #!/usr/bin/python 

 import ecmd

 # Initialize the Plugin - has to be first thing done
 # Here we pass in that we know this script supports eCMD Releases 1.x if we know we support more we could pass like "ver1,ver2"
 if (ecmd.ecmdLoadDll("", "ver1")):
    print("ERROR: Fatal errors initializing DLL")
    return 1
 </pre>


 <br>
 <hr>
 @section extinit Using eCMD Python Extensions
 If you need functionality from an eCMD Extension that provides the Python API, it is initialized like below.  This is a 'cip'
extension example but all extensions work the same way just replace the prefix with the extension of choice.
<br>
<pre>

 # Initialize the Plugin - has to be first thing done 
 if (ecmd.ecmdLoadDll("", "ver1")):
    print("ERROR: Fatal errors initializing DLL")
    return 1

 # Now initialize the extension as well
 # With the version 15 changes, this is no longer required by the user if the plugin you are using already does it.
 if (ecmd.cipInitExtension("ver1")):
    print("Fatal errors initializing CIP Extension")
    return 1

</pre>

 <br>
 <hr>
 @section dform Data Passing
 @subsection ecmdDataBuffer ecmdDataBuffer
 Data is passed between the client Python script and the eCMD shared object in the form of the same ecmdDataBuffer that is part of the C-Api.  The function set is the identical.  For additional documentation on the ecmdDataBuffer see the C/C++ Api Documentation.
<br>
Here is an example usage of the ecmdDataBuffer:
<pre>

  # Create a pointer to an DataBuffer class
  my data = ecmd.ecmdDataBuffer()

  # Set the size of my buffer
  data.setBitLength(32)

  # Set the first word of data in this class
  data.setWord(0,0xFEEDBEEF)

  # Read data from the chip
  rc = 0
  rc = ecmd.getRing(target, "idreg", data);

  # What is in the first word
  print("Data : %.08X" % data.getWord(0))

  # Change the value
  data.setWord(0,0xAAAA5555)
  print("Data : %.08X" % data.getWord(0))

  # Write my new value to the chip
  rc = ecmd.putRing(target, "idreg", data)
</pre>

 <b>WARNING: </b> The '=' operator DOES NOT work between ecmdDataBuffer's or any other structure like you would expect it to in C. See 'Python API Usage' below
<br>
 <hr>
@section target Chip/Object targeting
Python functions use the same ecmdChipTarget structure as the C-Api.

<pre>
  target = ecmd.ecmdChipTarget()
  target.chipType = "pu"
  target.cage = 0
  target.node = 0
  target.slot = 0
  target.pos = 1
  target.chipUnitNum = 0

  rc = ecmd.putRing(target, "idreg", data)

</pre>
 <b>WARNING: </b> The '=' operator DOES NOT work between ecmdChipTarget's or any other structure like you would expect it to in C. See 'Python API Usage' below

<br><br>
 <hr>
 @section pythonuse Python API Usage

 The following should be observed when using the Python API.

 <ol>
 <li> The ecmdLoadDll() function should ALWAYS be the first function called.</li>
 <li> The ecmdUnloadDll() function should be called just before script exit</li>
 </ol>

<br>
 @subsection operator The '=' operator
 <b>WARNING:</b> Because of the behavior of Python the following statements results in two variables pointing to the same data:
<pre>
  data1 = ecmd.ecmdDataBuffer()
  data1.setBitLength(32)
  data1.setWord(0,0xFEEDBEEF)

  # Use the = operator
  data2 = data1

  print("Data 1 : %.08X" % data1.getWord(0))        # This will echo 'Data 1 : FEEDBEEF'
  print("Data 2 : %.08X" % data2.getWord(0))        # This will echo 'Data 2 : FEEDBEEF'

  # Now just set Data 2
  data2.setWord(0,0xAAAA5555)

  print("Data 1 : %.08X", data1.getWord(0))        # This will echo 'Data 1 : AAAA5555'
  print("Data 2 : %.08X", data2.getWord(0))        # This will echo 'Data 2 : AAAA5555'
</pre>  
 NOTE : Since both data1 and data2 point to the same memory space when one is modified they are both modified.  This behavior is the same for the ecmdDataBuffer and all eCMD structures found in ecmdStructs.H

 To work around this problem you need to copy the contents of a structure manually :
 <ul>
 <li> For ecmdDataBuffer : data1.copy(data2)
 <li> For Structures : target2.cage = target.cage
 </ul>

 <br>
 <hr>
 @section pythonscript Example Python Script

 \include example.py

*/


#endif /* _ecmdClientPyapi_H */
