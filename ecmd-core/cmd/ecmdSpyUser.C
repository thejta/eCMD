//IBM_PROLOG_BEGIN_TAG
/* 
 * Copyright 2003,2016 IBM International Business Machines Corp.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * 	http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
 * implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
//IBM_PROLOG_END_TAG


//----------------------------------------------------------------------
//  Includes
//----------------------------------------------------------------------
#include <stdio.h>
#include <ctype.h>

#include <ecmdCommandUtils.H>
#include <ecmdReturnCodes.H>
#include <ecmdClientCapi.H>
#include <ecmdUtils.H>
#include <ecmdDataBuffer.H>
#include <ecmdInterpreter.H>
#include <ecmdSharedUtils.H>

//----------------------------------------------------------------------
//  User Types
//----------------------------------------------------------------------

//----------------------------------------------------------------------
//  Constants
//----------------------------------------------------------------------

//----------------------------------------------------------------------
//  Macros
//----------------------------------------------------------------------

//----------------------------------------------------------------------
//  Internal Function Prototypes
//----------------------------------------------------------------------

//----------------------------------------------------------------------
//  Global Variables
//----------------------------------------------------------------------

//---------------------------------------------------------------------
// Member Function Specifications
//---------------------------------------------------------------------
#ifndef ECMD_REMOVE_SPY_FUNCTIONS
uint32_t ecmdGetSpyUser(int argc, char * argv[]) {
  uint32_t rc = ECMD_SUCCESS, coeRc = ECMD_SUCCESS;

  bool expectFlag = false;
  ecmdLooperData looperData;            ///< Store internal Looper data
  ecmdLooperData cuLooper;              ///< Store internal Looper data for the chipUnit loop
  std::string outputformat = "default"; ///< Output format - default to 'enum' if enumerated otherwise 'x'
  std::string inputformat = "default";  ///< Expect data input format
  std::string expectArg;                ///< String containing expect data
  ecmdDataBuffer spyBuffer;             ///< Buffer to hold entire spy contents
  ecmdDataBuffer buffer;                ///< Buffer to hold user requested part of spy
  ecmdDataBuffer expectedRaw;           ///< Buffer to hold Raw expected data
  std::string expectedEnum;             ///< Buffer to hold enum expected data
  bool validPosFound = false;           ///< Did the looper find something?
  std::string printed;                  ///< Output string data
  std::string enumValue;                ///< The enum value returned
  ecmdChipTarget target;                ///< Current target being operated on
  ecmdChipTarget cuTarget;              ///< Current target being operated on for the chipUnits
  std::list<ecmdSpyData> spyDataList;   ///< Spy information returned by ecmdQuerySpy
  std::list<ecmdSpyData>::iterator spyData;   ///< spy data
  std::list<ecmdSpyGroupData> spygroups; ///< Spygroups information returned by GetSpyGroups
  //bool enabledCache = false;            ///< Did we enable the cache ?
  ecmdQueryDetail_t detail = ECMD_QUERY_DETAIL_LOW;  ///< Should we get all the possible info about this spy?
  uint8_t oneLoop = 0;                      ///< Used to break out of the chipUnit loop after the first pass for non chipUnit operations
  uint32_t spy_flags = 0;               ///< Flag to pass to spy functions
  ecmdChipData chipData;                ///< Chip data to find out sparse default value
  bool l_cond = false;                          ///< Use setpulse ring conditioning
  bool l_cond_all = false;                      ///< Use setpulse all ring conditioning


  /************************************************************************/
  /* Parse Local FLAGS here!                                              */
  /************************************************************************/
  //expect and mask flags check
  char * expectArgTmp = ecmdParseOptionWithArgs(&argc, &argv, "-exp");
  if (expectArgTmp != NULL) {
    expectFlag = true;
    expectArg = expectArgTmp;
  }

  /* get format flag, if it's there */
  char * formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-o");
  if (formatPtr != NULL) {
    outputformat = formatPtr;
  }

  formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-i");
  if (formatPtr != NULL) {
    inputformat = formatPtr;
  }
  //Check verbose option
  bool verbose = ecmdParseOption(&argc, &argv, "-v");

  if (verbose) {
    detail = ECMD_QUERY_DETAIL_HIGH;
  }

  //Check for mcast flag
  char * mcast = ecmdParseOptionWithArgs(&argc, &argv, "-mcast");
  if (mcast != NULL)
  {
      spy_flags = (uint32_t)strtol(mcast, NULL, 16);
      spy_flags |= ECMD_RING_MODE_MULTICAST;
  }

  //Check for sparse flag
  bool l_sparse = ecmdParseOption(&argc, &argv, "-sparse");
  if (l_sparse)
  {
      spy_flags |= ECMD_RING_MODE_SPARSE_ACCESS;
  }

  bool no_sparse = ecmdParseOption(&argc, &argv, "-nosparse");
  if (l_sparse && no_sparse)
  {
      ecmdOutputError("getspy - Cannot specify both -sparse and -nosparse at the same time. \n");
      return ECMD_INVALID_ARGS;
  }

  //Check for ring conditioning flags
  l_cond = ecmdParseOption(&argc, &argv, "-set_pulse_cond");

  l_cond_all = ecmdParseOption(&argc, &argv, "-set_pulse_cond_all");

  if ((l_cond) && (l_cond_all))
  {
      ecmdOutputError("getspy - Cannot specify both -set_pulse_cond and -set_pulse_cond_all at the same time. \n");
      return ECMD_INVALID_ARGS;
  }

  if (l_cond)
  {
      spy_flags |= ECMD_RING_MODE_SET_PULSE_SL;
  }

  if (l_cond_all)
  {
      spy_flags |= ECMD_RING_MODE_SET_PULSE_ALL;
  }
    
  
  /************************************************************************/
  /* Parse Common Cmdline Args                                            */
  /************************************************************************/
  rc = ecmdCommandArgs(&argc, &argv);
  if (rc) return rc;

  /* Global args have been parsed, we can read if -coe was given */
  bool coeMode = ecmdGetGlobalVar(ECMD_GLOBALVAR_COEMODE); ///< Are we in continue on error mode

  /* Now done with args, do an error check */
  if (argc < 2) {  //chip + address
    ecmdOutputError("getspy - Too few arguments specified; you need at least a chip and a spy.\n");
    ecmdOutputError("getspy - Type 'getspy -h' for usage.\n");
    return ECMD_INVALID_ARGS;
  }

  //Setup the target that will be used to query the system config 
  std::string chipType, chipUnitType;
  rc = ecmdParseChipField(argv[0], chipType, chipUnitType);
  if (rc) {
    ecmdOutputError("getspy - Wildcard character detected however it is not supported by this command.\n");
    return rc;
  }
  bool chipWildcardFound = false;

  target.cageState = target.nodeState = target.slotState = target.posState = ECMD_TARGET_FIELD_WILDCARD;
  target.chipUnitTypeState = target.chipUnitNumState = target.threadState = ECMD_TARGET_FIELD_UNUSED;


  if (chipType == "x") {
    target.chipTypeState = ECMD_TARGET_FIELD_WILDCARD;
    chipWildcardFound = true;
  } else {
    target.chipType = chipType;
    target.chipTypeState = ECMD_TARGET_FIELD_VALID;
  }

  /* The chipType was x and a chipUnitType was specified so lets set up the target correcly.  This 
     will force the queryScom functions to return only those chips with the specified chipUnit.  */
  if ((chipWildcardFound) && (chipUnitType != "")) {
    target.chipUnitType = chipUnitType;
    target.chipUnitTypeState = ECMD_TARGET_FIELD_VALID;
    target.chipUnitNumState = ECMD_TARGET_FIELD_WILDCARD;
  }

  //get spy name
  std::string spyName = argv[1];
  uint32_t startBit = 0x0, numBits = 0x0;

  rc = ecmdLooperInit(target, ECMD_SELECTED_TARGETS_LOOP, looperData);
  if (rc) return rc;

  while (ecmdLooperNext(target, looperData) && (!coeRc || coeMode)) {

    rc = ecmdGetChipData(target, chipData);
    if (rc) {
        coeRc = rc;
        continue;
    }

    if ((chipData.chipFlags & ECMD_CHIPFLAG_DEF_USE_SPARSE_SCAN) && !no_sparse) {
        spy_flags |= ECMD_RING_MODE_SPARSE_ACCESS;
    }
    // as of STGC00401862  we are disabling caching for spy accesses
    /* We are going to enable ring caching to speed up performance */
    /* Since we are in a target looper, the state fields should be set properly so just use this target */
    //if (!ecmdIsRingCacheEnabled(target)) {
    //  rc = ecmdEnableRingCache(target);
    //  if (rc) {
    //    ecmdOutputError("getspy - ecmdEnableRingCache call failed!\n");
    //    coeRc = rc;
    //    continue;
    //  }
    //  enabledCache = true;
    //}

    rc = ecmdQuerySpy(target, spyDataList, spyName.c_str(), detail);
    if (rc || spyDataList.empty()) {
      printed = "getspy - Error occured looking up data on spy " + spyName + " on ";
      printed += ecmdWriteTarget(target) + "\n";
      ecmdOutputError( printed.c_str() );
      coeRc = rc;
      continue;
    }

    spyData = spyDataList.begin();

    /* Make sure the user didn't request enum output on an ispy */
    if ((((outputformat == "enum") || (inputformat == "enum")) && !spyData->isEnumerated) && 
        // Don't want to error out if these conditions are also met. 
        // When using dial mode, isEnumerated is always set to false.  
        // Still allow user to specify enum in/out format if spyId and spyData have these values.  
        ((spyData->spyId != 0xDDDDDDDDDDDDDDDDULL) && (spyData->spyName != "DIAL"))) {
      ecmdOutputError("getspy - Spy doesn't support enumerations, can't use -ienum or -oenum\n");
      rc = ECMD_INVALID_ARGS;
      break;  
    }

    /* Ok, we need to find out what type of spy we are dealing with here, to find out how to output */
    if ((outputformat == "default") || (inputformat == "default")) {
      if (spyData->isEnumerated) {
        if (outputformat == "default") outputformat = "enum";
        if (inputformat == "default") inputformat = "enum";
      } else {
        if (outputformat == "default") outputformat = "x";
        if (inputformat == "default") inputformat = "x";
      }
    } 
    if ((outputformat == "enum") && (expectFlag && (inputformat != "enum"))) {
      /* We can't do an expect on non-enumerated when they want a fetch of enumerated */
      ecmdOutputError("getspy - When reading enumerated spy's both input and output format's must be of type 'enum'\n");
      rc = ECMD_INVALID_ARGS;
      break;
    }

    /* Now that we know whether it is enumerated or not, we can finally finish our arg parsing */
    if (outputformat != "enum") {
      if(argc == 3)
      {
          ecmdOutputError("getspy - Too few arguments specified; Specify both startbit and numbits\n");
          rc = ECMD_INVALID_ARGS;
          break;
      }

      if (argc > 3) {
        if (!ecmdIsAllDecimal(argv[2])) {
          ecmdOutputError("getspy - Non-decimal numbers detected in startbit field\n");
          rc = ECMD_INVALID_ARGS;
          break;
        }
        startBit = (uint32_t)atoi(argv[2]);
      }
      else {
        startBit = 0x0;
      }

      if (argc > 3) {
        if (!ecmdIsAllDecimal(argv[2])) {
          ecmdOutputError("getspy - Non-decimal numbers detected in startbit field\n");
          rc = ECMD_INVALID_ARGS;
          break;
        }
        if (!ecmdIsAllDecimal(argv[3])) {
          ecmdOutputError("getspy - Non-decimal numbers detected in numbits field\n");
          rc = ECMD_INVALID_ARGS;
          break;
        }
        startBit = (uint32_t)atoi(argv[2]);
        numBits = (uint32_t)atoi(argv[3]);
      }
      else {
        startBit = 0x0;
        numBits = ECMD_UNSET;
      }

      if (argc > 4) {
        ecmdOutputError("getspy - Too many arguments specified; you probably added an option that wasn't recognized.\n");
        ecmdOutputError("getspy - Type 'getspy -h' for usage.\n");
        rc = ECMD_INVALID_ARGS;
        break;
      }

      /* Bounds check */
      if ((numBits != ECMD_UNSET) && (startBit + numBits) > ECMD_MAX_DATA_BITS) {
        char errbuf[100];
        sprintf(errbuf,"getspy - Too much data requested > %d bits\n", ECMD_MAX_DATA_BITS);
        ecmdOutputError(errbuf);
        rc = ECMD_DATA_BOUNDS_OVERFLOW;
        break;
      }

    } else if (argc > 2) {
      ecmdOutputError("getspy - Too many arguments specified; you probably added an option that wasn't recognized.\n");
      ecmdOutputError("getspy - It is also possible you specified <start> <numbits> with an enumerated alias or dial\n");
      ecmdOutputError("getspy - Type 'getspy -h' for usage.\n");
      rc = ECMD_INVALID_ARGS;
      break;
    }

    /* Setup our chipUnit looper if needed */
    cuTarget = target;
    if (spyData->isChipUnitRelated) {
      /* Error check the chipUnit returned */
      if (!spyData->isChipUnitMatch(chipUnitType)) {
        printed = "getspy - Provided chipUnit \"";
        printed += chipUnitType;
        printed += "\"doesn't match chipUnit returned by querySpy \"";
        printed += spyData->relatedChipUnit + "\"\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
      /* If we have a chipUnit, set the state fields properly */
      if (chipUnitType != "") {
        cuTarget.chipUnitType = chipUnitType;
        cuTarget.chipUnitTypeState = ECMD_TARGET_FIELD_VALID;
      }
      cuTarget.chipUnitNumState = ECMD_TARGET_FIELD_WILDCARD;
      cuTarget.threadState = ECMD_TARGET_FIELD_UNUSED;

      /* Init the chipUnit loop */
      rc = ecmdLooperInit(cuTarget, ECMD_SELECTED_TARGETS_LOOP, cuLooper);
      if (rc) break;
    } else { // !spyData->isChipUnitRelated
      if (chipUnitType != "") {
        printed = "getspy - A chipUnit \"";
        printed += chipUnitType;
        printed += "\" was given on a non chipUnit spy\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
      // Setup the variable oneLoop variable for this non-chipUnit case
      oneLoop = 1;
    }

    /* If this isn't a chipUnit spy we will fall into while loop and break at the end, if it is we will call run through configloopernext */
    while ((spyData->isChipUnitRelated ? ecmdLooperNext(cuTarget, cuLooper) : (oneLoop--)) && (!coeRc || coeMode)) {


      //if (outputformat == "enum") {
      //  rc = getSpyEnum(cuTarget, spyName.c_str(), enumValue);
      //}
      //else {
      //  rc = getSpy(cuTarget, spyName.c_str(), spyBuffer);
      //}


      if (outputformat == "enum") {              // FW524017  HJH
        rc = getSpyEnum(cuTarget, spyName.c_str(), enumValue, spy_flags);
        if ( rc == ECMD_SPY_INVALID_READ_OPER) {
              rc = getSpy(cuTarget, spyName.c_str(), spyBuffer, spy_flags);
              if (rc == 0){   // .. printout warning informing that no enum could be found 
                  
                  printed = "getspy - Info: No enum found for Spy \"";
                  printed += spyName.c_str();
                  printed += "\" .. returning hex data instead\n";
                  ecmdOutputError(printed.c_str());

                  outputformat = "x";
              }
        }    
      }
      else {     // outputformat = x
        rc = getSpy(cuTarget, spyName.c_str(), spyBuffer, spy_flags);
      }




      if (rc == ECMD_SPY_FAILED_ECC_CHECK) {
        if (spyData->epCheckers.empty()) {
          ecmdOutputError("getspy - Got back the Spy Failed ECC return code, but no epcheckers specified\n");
        }
        ecmdDataBuffer inLatches, outLatches, errorMask;
        std::list<std::string>::iterator epcheckersIter = spyData->epCheckers.begin();
        int flag = 0;
        printed = "getspy - epcheckers \"";
        while (epcheckersIter != spyData->epCheckers.end()) {
          rc = getSpyEpCheckers(cuTarget, epcheckersIter->c_str(), inLatches, outLatches, errorMask, spy_flags);
          if (errorMask.getNumBitsSet(0,errorMask.getBitLength())) {
            if (flag) 
              printed += ", ";
            printed += *epcheckersIter;
            flag = 1;
          }
          epcheckersIter++;
        }
        printed += "\" mismatched on ";
        printed += ecmdWriteTarget(cuTarget) + "\n";
        ecmdOutputError( printed.c_str() );
        if (!verbose) {
          ecmdOutputError("Use -v option to get the detailed failure information\n");
          coeRc = rc;
          continue;
        } else {
          ecmdOutput("============================================================\n");
        }
      } else if (rc == ECMD_SPY_GROUP_MISMATCH) {
        printed = "getspy - Problems reading group spy - found a mismatch on ";
        printed += ecmdWriteTarget(cuTarget) + "\n";
        ecmdOutputError( printed.c_str() );
        if (!verbose) {
          ecmdOutputError("Use -v option to get the detailed failure information\n"); 
          coeRc = rc;
          continue;
        } else {
          ecmdOutput("============================================================\n");
        }
      } else if (rc) {
        printed = "getspy - Error occured performing getspy on ";
        printed += ecmdWriteTarget(cuTarget) + "\n";
        ecmdOutputError( printed.c_str() );
        coeRc = rc;
        continue;
      }
      validPosFound = true;     

      printed = ecmdWriteTarget(cuTarget) + " " + spyName;

      if (outputformat == "enum") {
        if (!expectFlag) {
          printed += "\n" + enumValue + "\n";
          ecmdOutput( printed.c_str() );
        } else {
	  expectedEnum = expectArg;
          if (expectedEnum != enumValue) {
            printed =  "getspy - Mismatch found on spy : " + spyName + "\n";
            ecmdOutputError( printed.c_str() );
            printed =  "getspy - Actual                : " + enumValue + "\n";
            ecmdOutputError( printed.c_str() );
            printed =  "getspy - Expected              : " + expectedEnum + "\n";
            ecmdOutputError( printed.c_str() );
            coeRc = ECMD_EXPECT_FAILURE;
            continue;
          }
        }
      }
      else {

        uint32_t bitsToFetch = 0x0;
        if (numBits == ECMD_UNSET) {
          bitsToFetch = spyBuffer.getBitLength() - startBit;
        }
        else {
          bitsToFetch = numBits;
        }

        buffer.setBitLength(bitsToFetch);
        spyBuffer.extract(buffer, startBit, bitsToFetch);

        char outstr[200];
        if (!expectFlag) {

          sprintf(outstr, "(%d:%d)", startBit, startBit + bitsToFetch - 1);
          printed += outstr;

          std::string dataStr = ecmdWriteDataFormatted(buffer, outputformat);
          if (dataStr[0] != '\n') {
            printed += "\n";
          }
          printed += dataStr;
          ecmdOutput( printed.c_str() );
        }
        else {

	  if (expectFlag) {
	    if (inputformat != "enum") {
	      if (inputformat == "d") 
	      {		  
		char msgbuf[100];
		// Can only use 32 bits for decimal values
		if (bitsToFetch > 32)
		{
		  sprintf(msgbuf,"Value too big for decimal representation (%d bits) - use Start and Numbits flags.\n", bitsToFetch);
		  ecmdOutputError(msgbuf);
		  rc = ECMD_DATA_BOUNDS_OVERFLOW;
		  break;
		}
		else if (bitsToFetch >(spyBuffer.getBitLength() - startBit)) 
		{
		  sprintf(msgbuf,"Too many bits requested. (%d bits)  More than size of the spy requested.\n", bitsToFetch);
		  ecmdOutputError(msgbuf);
		  rc = ECMD_DATA_BOUNDS_OVERFLOW;
		  break;
		}
              }

              rc = ecmdReadDataFormatted(expectedRaw, expectArg.c_str(), inputformat, bitsToFetch);
	      if (rc) break;
	    }
	  }

          uint32_t mismatchBit = 0;
          if (!ecmdCheckExpected(buffer, expectedRaw, mismatchBit)) {
            printed =  "getspy - Mismatch found on spy : " + spyName + "\n";
            ecmdOutputError( printed.c_str() );

            if (mismatchBit != ECMD_UNSET) {
              sprintf(outstr, "First bit mismatch found at bit %d\n",startBit + mismatchBit);
              ecmdOutputError( outstr );
            }

            printed =  "getspy - Actual                : ";
            printed += ecmdWriteDataFormatted(buffer, outputformat);
            ecmdOutputError( printed.c_str() );

            printed =  "getspy - Expected              : ";
            printed += ecmdWriteDataFormatted(expectedRaw, outputformat);
            ecmdOutputError( printed.c_str() );
            coeRc =  ECMD_EXPECT_FAILURE;
            continue;
          }
        }
      }
      /* Check if verbose then print details */
      if (verbose) {
        /* Get Spy Groups */
        bool l_has_groups = false; 
        getSpyGroups(cuTarget, spyName.c_str(), spygroups, spy_flags);
        if (rc && rc != ECMD_SPY_GROUP_MISMATCH && rc != ECMD_SPY_FAILED_ECC_CHECK) {
          coeRc = rc;
          continue;
        }
        std::list<ecmdSpyGroupData>::iterator groupiter = spygroups.begin();
        ecmdOutput("===== GroupData information for this spy ");
        printed = spyName + ": =====\n";
        ecmdOutput(printed.c_str());
        int i =0;
        char gpnum[50];
        while (groupiter != spygroups.end()) {
          sprintf(gpnum,"%3.3d",i);
          printed = "        Group " + (std::string)gpnum + ": 0x" + groupiter->extractBuffer.genHexLeftStr() + "\n";
          ecmdOutput(printed.c_str());
          printed = "   Dead Bits Mask: 0x" + groupiter->deadbitsMask.genHexLeftStr() + "\n";
          ecmdOutput(printed.c_str());
          i++;
          groupiter++;
          l_has_groups = true;
        }
        /* Ecc Checkers */
        /* Must have entries - setup variables and iterators, start looping */
        ecmdDataBuffer inLatches, outLatches, errorMask;
        std::list<std::string>::iterator epcheckersIter = spyData->epCheckers.begin();
        ecmdOutput("===== epcheckers information for this spy ");
        printed = spyName + ": =====\n";
        ecmdOutput(printed.c_str());
        while (epcheckersIter != spyData->epCheckers.end()) {
          rc = getSpyEpCheckers(cuTarget, epcheckersIter->c_str(), inLatches, outLatches, errorMask, spy_flags);
          if (rc && rc != ECMD_SPY_FAILED_ECC_CHECK && rc != ECMD_SPY_GROUP_MISMATCH) {
            coeRc = rc;
            continue;
          }
          printed = *epcheckersIter + "\n";
          ecmdOutput(printed.c_str());
          printed = "   In Latches: 0x" + inLatches.genHexLeftStr() + "\n";
          ecmdOutput(printed.c_str());
          printed = "  Out Latches: 0x" + outLatches.genHexLeftStr() + "\n";
          ecmdOutput(printed.c_str());
          printed = "   Error Mask: 0x" + errorMask.genHexLeftStr() + "\n";
          ecmdOutput(printed.c_str());
          epcheckersIter++;
        }
        /* Spy Latch Data */
        std::list<ecmdSpyLatchData>::iterator latchDataIter = spyData->spyLatches.begin();
        ecmdOutput("===== latch information for this spy ");
        printed = spyName + ": =====\n";
        ecmdOutput(printed.c_str());
        char tempstr[50];
        uint32_t offset = 0;
        if (!spyData->isEnumerated) { // Can't do this on enumerated spies
          if (l_has_groups)
          {
              //reuse some stuff from earlier
              i = 0;
              groupiter = spygroups.begin();
              sprintf(gpnum,"%3.3d",i);
              printed = "   ===== Group " + (std::string)gpnum + " =====\n";
              ecmdOutput(printed.c_str());
          }
          while (latchDataIter != spyData->spyLatches.end()) {
            // Format my data
            if (l_has_groups)
            {   
                sprintf(tempstr,"   %s%-8s ", (((uint32_t)latchDataIter->length > 8) ? "0x" : "0b"), (((uint32_t)latchDataIter->length > 8) ? groupiter->extractBuffer.genHexLeftStr(offset, (uint32_t)latchDataIter->length).c_str() : groupiter->extractBuffer.genBinStr(offset, (uint32_t)latchDataIter->length).c_str()));
            }
            else
            {
                sprintf(tempstr,"   %s%-8s ", (((uint32_t)latchDataIter->length > 8) ? "0x" : "0b"), (((uint32_t)latchDataIter->length > 8) ? spyBuffer.genHexLeftStr(offset, (uint32_t)latchDataIter->length).c_str() : spyBuffer.genBinStr(offset, (uint32_t)latchDataIter->length).c_str()));
            }
            printed = tempstr;
            // Now tack on the latch name
            printed += latchDataIter->latchName;
            printed += "\n";
            ecmdOutput(printed.c_str());

            // Walk some stuff
            offset += (uint32_t)latchDataIter->length;
            // For groups, we're returning latch data now for all groups
            // Reset the offset when it reaches the length and move to next group buf
            if (l_has_groups && (offset >= groupiter->extractBuffer.getBitLength()))
            {
                offset = 0;
                groupiter++;
                if (groupiter != spygroups.end())
                {
                    i++;
                    sprintf(gpnum,"%3.3d",i);
                    printed = "   ===== Group " + (std::string)gpnum + " =====\n";
                    ecmdOutput(printed.c_str());
                }

            } 
            latchDataIter++;
          }
        }
        ecmdOutput("============================================================\n");
      }
      
      // We only want to go through the cu looper one time in multicast mode
      if (spy_flags & ECMD_RING_MODE_MULTICAST)
      {
          break;  
      }
    } /* End cuLooper */

    // as of STGC00401862  we are disabling caching for spy accesses
    /* Now that we are moving onto the next target, let's flush the cache we have */
    //if (enabledCache) {
    //  enabledCache = false;
    //  uint32_t trc = ecmdDisableRingCache(target);
    //  if (trc) {
    //    ecmdOutputError("getspy - Problems disabling the ring cache\n");
    //    coeRc = trc;
    //    continue;
    //  }
    //}
  } /* End poslooper */
  // coeRc will be the return code from in the loop, coe mode or not.
  if (coeRc) return coeRc;

  if (!validPosFound && !rc) {
    ecmdOutputError("getspy - Unable to find a valid chip to execute command on\n");
    return ECMD_TARGET_NOT_CONFIGURED;
  }



  // as of STGC00401862  we are disabling caching for spy accesses
  //if (enabledCache) {
  //  enabledCache = false;
  //  uint32_t trc = ecmdDisableRingCache(target);
  //  if (trc) {
  //    ecmdOutputError("getspy - Problems disabling the ring cache\n");
  //    coeRc = trc;
  //  }
  //}

  return rc;
}

uint32_t ecmdPutSpyUser(int argc, char * argv[]) {
  uint32_t rc = ECMD_SUCCESS , coeRc = ECMD_SUCCESS;


  ecmdLooperData looperData;            ///< Store internal Looper data
  ecmdLooperData cuLooper;              ///< Store internal Looper data for the chipUnit loop
  std::string inputformat = "default";  ///< Input data format
  std::string dataModifier = "insert";  ///< Default data modifier
  uint32_t startBit = ECMD_UNSET;       //@01 add init 
  uint32_t numBits  = 0; 
  ecmdDataBuffer buffer;                ///< Buffer to hold input data
  ecmdDataBuffer spyBuffer;             ///< Buffer to hold current spy data
  ecmdChipTarget target;                ///< Current target
  ecmdChipTarget cuTarget;              ///< Current target being operated on for the chipUnits
  bool validPosFound = false;           ///< Did the looper find anything?
  std::string printed;                  ///< Output data
  std::list<ecmdSpyData> spyDataList;           ///< Spy information returned by ecmdQuerySpy
  std::list<ecmdSpyData>::iterator spyData;     ///< Spy information returned by ecmdQuerySpy
  //bool enabledCache = false;            ///< Did we enable the cache ?
  uint8_t oneLoop = 0;                      ///< Used to break out of the chipUnit loop after the first pass for non chipUnit operations
  uint32_t spy_flags = 0;               ///< Flag to pass to spy functions
  ecmdChipData chipData;                        ///< Chip data to find out sparse default value
  bool l_cond = false;                          ///< Use setpulse ring conditioning
  bool l_cond_all = false;                      ///< Use setpulse all ring conditioning
  uint32_t l_read_spy_flags = 0;
  uint32_t l_write_spy_flags = 0;

  char * formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-i");
  if (formatPtr != NULL) {
    inputformat = formatPtr;
  }

  formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-b");
  if (formatPtr != NULL) {
    dataModifier = formatPtr;
  }

  //Check for mcast flag
  char * mcast = ecmdParseOptionWithArgs(&argc, &argv, "-mcast");
  if (mcast != NULL)
  {
      spy_flags = (uint32_t)strtol(mcast, NULL, 16);
      spy_flags |= ECMD_RING_MODE_MULTICAST;
      l_read_spy_flags = l_write_spy_flags = spy_flags;
  }

  //Check for sparse flag
  bool l_sparse = ecmdParseOption(&argc, &argv, "-sparse");
  if (l_sparse)
  {
      l_read_spy_flags |= ECMD_RING_MODE_SPARSE_ACCESS;
      l_write_spy_flags |= ECMD_RING_MODE_SPARSE_ACCESS;
  }

  bool no_sparse = ecmdParseOption(&argc, &argv, "-nosparse");
  if (l_sparse && no_sparse)
  {
      ecmdOutputError("putspy - Cannot specify both -sparse and -nosparse at the same time. \n");
      return ECMD_INVALID_ARGS;
  }

  //Check for ring conditioning flags
  l_cond = ecmdParseOption(&argc, &argv, "-set_pulse_cond");

  l_cond_all = ecmdParseOption(&argc, &argv, "-set_pulse_cond_all");

  if ((l_cond) && (l_cond_all))
  {
      ecmdOutputError("putspy - Cannot specify both -set_pulse_cond and -set_pulse_cond_all at the same time. \n");
      return ECMD_INVALID_ARGS;
  }

  if (l_cond)
  {
      l_read_spy_flags |= ECMD_RING_MODE_SET_PULSE_SL;
      l_write_spy_flags |= ECMD_RING_MODE_SET_PULSE_NSL;
  }

  if (l_cond_all)
  {
      l_read_spy_flags |= ECMD_RING_MODE_SET_PULSE_ALL;
      l_write_spy_flags |= ECMD_RING_MODE_SET_PULSE_ALL;
  }


  /************************************************************************/
  /* Parse Common Cmdline Args                                            */
  /************************************************************************/
  rc = ecmdCommandArgs(&argc, &argv);
  if (rc) return rc;



   /* Global args have been parsed, we can read if -coe was given */
  bool coeMode = ecmdGetGlobalVar(ECMD_GLOBALVAR_COEMODE); ///< Are we in continue on error mode



  if (argc < 3) {  //chip + address
    ecmdOutputError("putspy - Too few arguments specified; you need at least a chip, a spy, and data.\n");
    ecmdOutputError("putspy - Type 'putspy -h' for usage.\n");
    return ECMD_INVALID_ARGS;
  }

  //Setup the target that will be used to query the system config 
  std::string chipType, chipUnitType;
  rc = ecmdParseChipField(argv[0], chipType, chipUnitType);
  if (rc) {
    ecmdOutputError("putspy - Wildcard character detected however it is not supported by this command.\n");
    return rc;
  }
  target.chipType = chipType;
  target.chipTypeState = ECMD_TARGET_FIELD_VALID;
  target.cageState = target.nodeState = target.slotState = target.posState = ECMD_TARGET_FIELD_WILDCARD;
  target.chipUnitTypeState = target.chipUnitNumState = target.threadState = ECMD_TARGET_FIELD_UNUSED;

  //get spy name
  std::string spyName = argv[1];

  /************************************************************************/
  /* Kickoff Looping Stuff                                                */
  /************************************************************************/

  rc = ecmdLooperInit(target, ECMD_SELECTED_TARGETS_LOOP, looperData);
  if (rc) return rc;

  while (ecmdLooperNext(target, looperData) && (!coeRc || coeMode)) {

    rc = ecmdGetChipData(target, chipData);
    if (rc) {
        coeRc = rc;
        continue;     
    }
     
   if ((chipData.chipFlags & ECMD_CHIPFLAG_DEF_USE_SPARSE_SCAN) && !no_sparse) {
       l_read_spy_flags |= ECMD_RING_MODE_SPARSE_ACCESS;
       l_write_spy_flags |= ECMD_RING_MODE_SPARSE_ACCESS;
   }

    // as of STGC00401862  we are disabling caching for spy accesses
    /* We are going to enable ring caching to speed up performance */
    //if (!ecmdIsRingCacheEnabled(target)) {
    //  rc = ecmdEnableRingCache(target);
    //  if (rc) {
    //    ecmdOutputError("putspy - ecmdEnableRingCache call failed!\n");
    //    coeRc = rc;
    //    continue;
    //  }
    //  enabledCache = true;
    //}

    /* Ok, we need to find out what type of spy we are dealing with here, to find out how to output */
    rc = ecmdQuerySpy(target, spyDataList, spyName.c_str(), ECMD_QUERY_DETAIL_LOW);
    if (rc || spyDataList.empty()) {
      printed = "putspy - Error occured looking up data on spy " + spyName + " on ";
      printed += ecmdWriteTarget(target) + "\n";
      ecmdOutputError( printed.c_str() );
      coeRc = rc;
      continue;
    }

    spyData = spyDataList.begin();
    if (spyData->isEnumerated) {
      if (inputformat == "default") inputformat = "enum";
    } else {
      if (inputformat == "default") inputformat = "x";
    }

    /* Now that we know whether it is enumerated or not, we can finally finish our arg parsing */
    if (inputformat != "enum") {
      if (argc > 3) {
        if (argc != 5) {
          ecmdOutputError("putspy - Too many arguments specified; you probably added an option that wasn't recognized.\n");
          ecmdOutputError("putspy - Type 'putspy -h' for usage.\n");
          rc = ECMD_INVALID_ARGS;
          break;
        }

        if (!ecmdIsAllDecimal(argv[2])) {
          ecmdOutputError("putspy - Non-decimal numbers detected in startbit field\n");
          rc = ECMD_INVALID_ARGS;
          break;
        }
        startBit = (uint32_t)atoi(argv[2]);

        if (!ecmdIsAllDecimal(argv[3])) {
          ecmdOutputError("putspy - Non-decimal numbers detected in numbits field\n");
          rc = ECMD_INVALID_ARGS;
          break;
        }
        numBits = (uint32_t)atoi(argv[3]);

        rc = ecmdReadDataFormatted(buffer, argv[4], inputformat, numBits);
        if (rc) {
          ecmdOutputError("putspy - Problems occurred parsing input data, must be an invalid format\n");
          break;
        }

      } else {
        rc = ecmdReadDataFormatted(buffer, argv[2], inputformat, spyData->bitLength);
        if (rc) {
          ecmdOutputError("putspy - Problems occurred parsing input data, must be an invalid format\n");
          break;
        }
      }
    }

    /* Setup our chipUnit looper if needed */
    cuTarget = target;
    if (spyData->isChipUnitRelated) {
      /* Error check the chipUnit returned */
      if (!spyData->isChipUnitMatch(chipUnitType)) {
        printed = "putspy - Provided chipUnit \"";
        printed += chipUnitType;
        printed += "\"doesn't match chipUnit returned by querySpy \"";
        printed += spyData->relatedChipUnit + "\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
      /* If we have a chipUnit, set the state fields properly */
      if (chipUnitType != "") {
        cuTarget.chipUnitType = chipUnitType;
        cuTarget.chipUnitTypeState = ECMD_TARGET_FIELD_VALID;
      }
      cuTarget.chipUnitNumState = ECMD_TARGET_FIELD_WILDCARD;
      cuTarget.threadState = ECMD_TARGET_FIELD_UNUSED;

      /* Init the chipUnit loop */
      rc = ecmdLooperInit(cuTarget, ECMD_SELECTED_TARGETS_LOOP, cuLooper);
      if (rc) break;
    } else { // !spyData->isChipUnitRelated
      if (chipUnitType != "") {
        printed = "putspy - A chipUnit \"";
        printed += chipUnitType;
        printed += "\" was given on a non chipUnit spy\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
      // Setup the variable oneLoop variable for this non-chipUnit case
      oneLoop = 1;
    }

    /* If this isn't a chipUnit spy we will fall into while loop and break at the end, if it is we will call run through configloopernext */
    while ((spyData->isChipUnitRelated ? ecmdLooperNext(cuTarget, cuLooper) : (oneLoop--)) && (!coeRc || coeMode)) {

      if ((inputformat != "enum") && ((dataModifier != "insert") || (startBit != ECMD_UNSET))) {

        rc = getSpy(cuTarget, spyName.c_str(), spyBuffer, l_read_spy_flags);

        if ((rc == ECMD_SPY_GROUP_MISMATCH) && (numBits == spyData->bitLength)) {
          /* We will go on if the user was going to write the whole spy anyway */
          ecmdOutputWarning("putspy - Problems reading group spy - found a mismatch - going ahead with write\n");
          rc = 0;
        } else if (rc == ECMD_SPY_GROUP_MISMATCH) {
          /* If the user was only going to write part of the spy we can't go on because we don't ahve valid data to merge with */
          printed = "putspy - Problems reading group spy - found a mismatch - to force write don't use start/numbits - on ";
          printed += ecmdWriteTarget(cuTarget) + "\n";
          ecmdOutputError( printed.c_str() );
          ecmdOutputError("Use getspy with the -v option to get the detailed failure information\n");
          coeRc = rc;
          continue;
        } else if (rc == ECMD_SPY_FAILED_ECC_CHECK) {
          ecmdOutputWarning("putspy - Problems reading spy - ECC check failed - going ahead with write\n");
          rc = 0;
        } else if (rc) {
          printed = "putspy - Error occured performing getspy on ";
          printed += ecmdWriteTarget(cuTarget) + "\n";
          ecmdOutputError( printed.c_str() );
          coeRc = rc;
          continue;
        } else {
          validPosFound = true;     
        }

        rc = ecmdApplyDataModifier(spyBuffer, buffer, (startBit == ECMD_UNSET ? 0 : startBit), dataModifier);
        if (rc) { 
          coeRc = rc;
          continue;
        }

        rc = putSpy(cuTarget, spyName.c_str(), spyBuffer, l_write_spy_flags);
        if (rc) {
          printed = "putspy - Error occured performing putspy on ";
          printed += ecmdWriteTarget(cuTarget) + "\n";
          ecmdOutputError( printed.c_str() );
          coeRc = rc;
          continue;
        }
      } else {

        if (inputformat == "enum") {
          rc = putSpyEnum(cuTarget, spyName.c_str(), argv[argc-1], l_write_spy_flags);
        } else {
          rc = putSpy(cuTarget, spyName.c_str(), buffer, l_write_spy_flags);
        }

        if (rc) {
          printed = "putspy - Error occured performing putspy on ";
          printed += ecmdWriteTarget(cuTarget) + "\n";
          ecmdOutputError( printed.c_str() );
          coeRc = rc;
          continue;
        } else {
          validPosFound = true;
        }
      }

      if (!ecmdGetGlobalVar(ECMD_GLOBALVAR_QUIETMODE)) {
        printed = ecmdWriteTarget(cuTarget) + "\n";
        ecmdOutput(printed.c_str());
      }

      // We only want to go through the cu looper one time in multicast mode
      if (spy_flags & ECMD_RING_MODE_MULTICAST)
      {
          break;  
      }
    } /* End cuLooper */

    // as of STGC00401862  we are disabling caching for spy accesses
    /* Now that we are moving onto the next target, let's flush the cache we have */
    //if (enabledCache) {
    //  uint32_t trc = ecmdDisableRingCache(target);
    //  if (trc) {
    //    ecmdOutputError("putspy - Problems disabling the ring cache\n");
    //    coeRc = trc;
    //    continue;
    //  }
    //  enabledCache = false;
    //}

  } /* End poslooper */
  // coeRc will be the return code from in the loop, coe mode or not.
  if (coeRc) return coeRc;

  if (!validPosFound && !rc) {
    ecmdOutputError("putspy - Unable to find a valid chip to execute command on\n");
    return ECMD_TARGET_NOT_CONFIGURED;
  }

  return rc;
}
uint32_t ecmdGetSpyImageUser(int argc, char * argv[]) {

  uint32_t rc = ECMD_SUCCESS, coeRc = ECMD_SUCCESS;
  bool expectFlag = false;
  ecmdLooperData looperData;            ///< Store internal Looper data
  ecmdLooperData cuLooper;              ///< Store internal Looper data for the chipUnit loop
  std::string outputformat = "default"; ///< Output format - default to 'enum' if enumerated
                                        ///  otherwise 'x'
  std::string inputformat = "default";  ///< Expect data input format
  std::string ringImageFormat = "b";    ///< By Default the ring image format is Binary.
  std::string expectArg;                ///< String containing expect data
  ecmdDataBuffer spyBuffer;             ///< Buffer to hold entire spy contents
  ecmdDataBuffer buffer;                ///< Buffer to hold user requested part of spy
  ecmdDataBuffer expectedRaw;           ///< Buffer to hold Raw expected data
  std::string expectedEnum;             ///< Buffer to hold enum expected data
  bool validPosFound = false;           ///< Did the looper find something?
  std::string printed;                  ///< Output string data
  std::string enumValue;                ///< The enum value returned
  ecmdChipTarget target;                ///< Current target being operated on
  ecmdChipTarget cuTarget;              ///< Current target being operated on for the chipUnits
  std::list<ecmdSpyData> spyDataList;   ///< Spy information returned by ecmdQuerySpy
  std::list<ecmdSpyData>::iterator spyData;   ///< spy data
  std::list<ecmdSpyGroupData> spygroups; ///< Spygroups information returned by GetSpyGroups
  ecmdQueryDetail_t detail = ECMD_QUERY_DETAIL_LOW;  ///< Should we get all the possible info about this spy?
  uint8_t oneLoop = 0;                      ///< Used to break out of the chipUnit loop after the first pass for non chipUnit operations
  /************************************************************************/
  /* Parse Local FLAGS here!                                              */
  /************************************************************************/
  //expect and mask flags check
  char * expectArgTmp = ecmdParseOptionWithArgs(&argc, &argv, "-exp");
  if (expectArgTmp != NULL) {
    expectFlag = true;
    expectArg = expectArgTmp;
  }

  /* get format flag, if it's there */
  char * formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-o");
  if (formatPtr != NULL) {
    outputformat = formatPtr;
  }
  formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-i");
  if (formatPtr != NULL) {
    inputformat = formatPtr;
  }
  formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-fi");
  if (formatPtr != NULL) {
    ringImageFormat = formatPtr;
  }
  /************************************************************************/
  /* Parse Common Cmdline Args                                            */
  /************************************************************************/
  rc = ecmdCommandArgs(&argc, &argv);
  if (rc) return rc;

  /* Global args have been parsed, we can read if -coe was given */
  bool coeMode = ecmdGetGlobalVar(ECMD_GLOBALVAR_COEMODE); ///< Are we in continue on error mode

  /* Now done with args, do an error check */
  if (argc < 3) {  //chip + spyname + ringIname
    ecmdOutputError("getspyimage - Too few arguments specified; you need at least a chip, spyname and ringimage.\n");
    ecmdOutputError("getspyimage - Type 'getspyimage -h' for usage.\n");
    return ECMD_INVALID_ARGS;
  }
  //Setup the target that will be used to query the system config
  std::string chipType, chipUnitType;
  ecmdParseChipField(argv[0], chipType, chipUnitType);
  target.chipType = chipType;
  target.chipTypeState = ECMD_TARGET_FIELD_VALID;
 target.cageState = target.nodeState = target.slotState = target.posState = ECMD_TARGET_FIELD_WILDCARD;
  target.chipUnitTypeState = target.chipUnitNumState = target.threadState = ECMD_TARGET_FIELD_UNUSED;

  //get spy name
  std::string spyName = argv[1];
  char *  ringImagefile = argv[2];
  ecmdDataBuffer ringImage;
  // Check if the user specified ring image format is correct
  if(ringImageFormat == "a" )
  {
     //  input is ASCII and hence reading it in  ASCII Format
     rc = ringImage.readFile(ringImagefile, ECMD_SAVE_FORMAT_ASCII);
  }
  else if(ringImageFormat == "b")
  {
     // User Input is Binary
     // Checking if it is  ASCII
     // if the image is ASCII, we error out
     // If it is not ASCII, we go ahead and read it as BINARY Format.
     rc = ringImage.readFile(ringImagefile, ECMD_SAVE_FORMAT_ASCII);
     if(!rc)
     {
       ecmdOutputError("getspyimage - Input Specified is Binary but image format is ASCII ");
       ecmdOutputError("getspyimage - Type 'getspyimage -h' for usage.\n");
       rc = ECMD_DBUF_INVALID_DATA_FORMAT;
     }
     else
       rc = ringImage.readFile(ringImagefile, ECMD_SAVE_FORMAT_BINARY_DATA);
  }
  // If specified ring image format is neither "a" nor "b",then error out.
  else
  {
    // If the user option is not -fia or fib , we error out.
    ecmdOutputError("getspyimage - Invalid ring image format.\n");
    ecmdOutputError("getspyimage - Type 'getspyimage -h' for usage.\n");
    rc=ECMD_INVALID_ARGS;
  }
  if(rc) return rc;
  uint32_t startBit = 0x0;
  rc = ecmdLooperInit(target, ECMD_SELECTED_TARGETS_LOOP, looperData);
  if (rc) return rc;
  while (ecmdLooperNext(target, looperData) && (!coeRc || coeMode)) {

    rc = ecmdQuerySpy(target, spyDataList, spyName.c_str(), detail);
    if (rc || spyDataList.empty()) {
      printed = "getspyimage - Error occured looking up data on spy " + spyName + " on ";
      printed += ecmdWriteTarget(target) + "\n";
      ecmdOutputError( printed.c_str() );
      coeRc = rc;
      continue;
    }
    spyData = spyDataList.begin();
     /* Make sure the user didn't request enum output on an ispy */
    if (((outputformat == "enum") || (inputformat == "enum")) && !spyData->isEnumerated) {
      ecmdOutputError("getspyimage - Spy doesn't support enumerations, can't use -ienum or -oenum\n");
      rc = ECMD_INVALID_ARGS;
      break;
    }
 /* Ok, we need to find out what type of spy we are dealing with here, to find out how to output */
    if ((outputformat == "default") || (inputformat == "default")) {
      if (spyData->isEnumerated) {
        if (outputformat == "default") outputformat = "enum";
        if (inputformat == "default") inputformat = "enum";
      } else {
        if (outputformat == "default") outputformat = "x";
        if (inputformat == "default") inputformat = "x";
      }
    }
    if ((outputformat == "enum") && (inputformat != "enum")) {
      /* We can't do an expect on non-enumerated when they want a fetch of enumerated */
      ecmdOutputError("getspyimage - When reading enumerated spy's both input and output format's must be of type 'enum'\n");
      rc = ECMD_INVALID_ARGS;
      break;
    }

 /* Setup our chipUnit looper if needed */
    cuTarget = target;
    if (spyData->isChipUnitRelated) {
      /* Error check the chipUnit returned */
      if (!spyData->isChipUnitMatch(chipUnitType)) {
        printed = "getspyimage - Provided chipUnit \"";
        printed += chipUnitType;
        printed += "\"doesn't match chipUnit returned by querySpy \"";
        printed += spyData->relatedChipUnit + "\"\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
      /* If we have a chipUnit, set the state fields properly */
       if (chipUnitType != "") {
        cuTarget.chipUnitType = chipUnitType;
        cuTarget.chipUnitTypeState = ECMD_TARGET_FIELD_VALID;
      }

      cuTarget.chipUnitNumState = ECMD_TARGET_FIELD_WILDCARD;
      cuTarget.threadState = ECMD_TARGET_FIELD_UNUSED;

      /* Init the chipUnit loop */
      rc = ecmdLooperInit(cuTarget, ECMD_SELECTED_TARGETS_LOOP, cuLooper);
      if (rc) break;
    } else { // !spyData->isChipUnitRelated
      if (chipUnitType != "") {
        printed = "getspyimage - A chipUnit \"";
        printed += chipUnitType;
        printed += "\" was given on a non chipUnit spy\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
 // Setup the variable oneLoop variable for this non-chipUnit case
      oneLoop = 1;
    }

    /* If this isn't a chipUnit spy we will fall into while loop and break at the end, if it is we will call run through configloopernext */
    while ((spyData->isChipUnitRelated ? ecmdLooperNext(cuTarget, cuLooper) : (oneLoop--)) && (!coeRc || coeMode)) {
      if(outputformat == "enum") {
        rc = getSpyEnumImage(cuTarget, spyName.c_str(),ringImage, enumValue);
        if ( rc ) {
          rc = getSpyImage(cuTarget, spyName.c_str(),ringImage, spyBuffer);
          if (rc == 0){   // .. printout warning informing that no enum could be found
            printed = "getspyimage - Info: No enum found for Spy \"";
            printed += spyName.c_str();
            printed += "\" .. returning hex data instead\n";
            ecmdOutputError(printed.c_str());
            outputformat = "x";
          }
        }
      }
      else {
        rc = getSpyImage(cuTarget, spyName.c_str(), ringImage,spyBuffer);
      }
      if (rc) {
        if (rc == ECMD_MULTIPLE_RING_IMAGE_SPY)
        {
            printed = "getspyimage - Command line support for multiple ring images is not supported.  You must use the APIs.\n";
        }
        else
        {
            printed = "getspyimage - Error occured performing getspyimage on ";
            printed += ecmdWriteTarget(cuTarget) + "\n";
        }
        ecmdOutputError( printed.c_str() );
        coeRc = rc;
        continue;
      }
      validPosFound = true;

      printed = ecmdWriteTarget(cuTarget) + " " + spyName;

      if (outputformat == "enum") {
	if (!expectFlag) {
          printed += "\n" + enumValue + "\n";
          ecmdOutput( printed.c_str() );
        } else {
          expectedEnum = expectArg;
          if (expectedEnum != enumValue) {
            printed =  "getspyimage - Mismatch found on spy : " + spyName + "\n";
            ecmdOutputError( printed.c_str() );
            printed =  "getspyimage - Actual                : " + enumValue + "\n";
            ecmdOutputError( printed.c_str() );
            printed =  "getspyimage - Expected              : " + expectedEnum + "\n";
            ecmdOutputError( printed.c_str() );
            coeRc = ECMD_EXPECT_FAILURE;
            continue;
          }
        }
      }
      else {
        uint32_t bitsToFetch = 0x0;
        bitsToFetch = spyBuffer.getBitLength() - startBit;
        buffer.setBitLength(bitsToFetch);
        spyBuffer.extract(buffer, startBit, bitsToFetch);
        char outstr[200];
        if (!expectFlag) {

          sprintf(outstr, "(%d:%d)", startBit, startBit + bitsToFetch - 1);
          printed += outstr;

          std::string dataStr = ecmdWriteDataFormatted(buffer, outputformat);
          if (dataStr[0] != '\n') {
            printed += "\n";
          }
          printed += dataStr;
          ecmdOutput( printed.c_str() );
        }
        else {


	  if (inputformat != "enum") {
            rc = ecmdReadDataFormatted(expectedRaw, expectArg.c_str(), inputformat, bitsToFetch);
	    if (rc) break;
	  }
    
          uint32_t mismatchBit = 0;
          if (!ecmdCheckExpected(buffer, expectedRaw, mismatchBit)) {
            printed =  "getspyimage - Mismatch found on spy : " + spyName + "\n";
            ecmdOutputError( printed.c_str() );

            if (mismatchBit != ECMD_UNSET) {
              sprintf(outstr, "First bit mismatch found at bit %d\n",startBit + mismatchBit);
              ecmdOutputError( outstr );
            }
            printed =  "getspyimage - Actual                : ";
            printed += ecmdWriteDataFormatted(buffer, outputformat);
            ecmdOutputError( printed.c_str() );

            printed =  "getspyimage - Expected              : ";
            printed += ecmdWriteDataFormatted(expectedRaw, outputformat);
            ecmdOutputError( printed.c_str() );
            coeRc =  ECMD_EXPECT_FAILURE;
            continue;
          }
        }
      }
    } /* End cuLooper */

  } /* End poslooper */
  // coeRc will be the return code from in the loop, coe mode or not.
  if (coeRc) return coeRc;

  if (!validPosFound && !rc ) {
    ecmdOutputError("getspyimage - Unable to find a valid chip to execute command on\n");
    return ECMD_TARGET_NOT_CONFIGURED;
  }
  return rc;
}

uint32_t ecmdPutSpyImageUser(int argc, char * argv[]) {

  uint32_t rc = ECMD_SUCCESS , coeRc = ECMD_SUCCESS;
  ecmdLooperData looperData;            ///< Store internal Looper data
  ecmdLooperData cuLooper;              ///< Store internal Looper data for the chipUnit loop
  std::string inputformat = "default";  ///< Input data format,default xl
  std::string ringformat = "b";         ///< ring image format ,default binary
  ecmdDataBuffer buffer;                ///< Buffer to hold input data
  ecmdDataBuffer spyBuffer;             ///< Buffer to hold current spy data
  ecmdChipTarget target;                ///< Current target
  ecmdChipTarget cuTarget;              ///< Current target being operated on for the chipUnits
  bool validPosFound = false;           ///< Did the looper find anything?
  std::string printed;                  ///< Output data
  std::list<ecmdSpyData> spyDataList;           ///< Spy information returned by ecmdQuerySpy
  std::list<ecmdSpyData>::iterator spyData;     ///< Spy information returned by ecmdQuerySpy
  uint8_t oneLoop = 0;                      ///< Used to break out of the chipUnit loop after the first pass for non chipUnit operations

  char * formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-i");
  if (formatPtr != NULL) {
    inputformat = formatPtr;
  }

  formatPtr = ecmdParseOptionWithArgs(&argc, &argv, "-fi");
  if (formatPtr != NULL) {
    ringformat = formatPtr;
  }
  /************************************************************************/
  /* Parse Common Cmdline Args                                            */
  /************************************************************************/
  rc = ecmdCommandArgs(&argc, &argv);
  if (rc) return rc;

   /* Global args have been parsed, we can read if -coe was given */
  bool coeMode = ecmdGetGlobalVar(ECMD_GLOBALVAR_COEMODE); ///< Are we in continue on error mode
if (argc < 4 ) {  //chip + spy + ringimage +data
    ecmdOutputError("putspyimage - Too few arguments specified; you need at least a chip, a spy,ring image and data.\n");
    ecmdOutputError("putspyimage - Type 'putspyimage -h' for usage.\n");
    return ECMD_INVALID_ARGS;
  }
  if(argc > 4 )
  {
    ecmdOutputError("putspyimage - Too many  arguments specified; you need  chip, a spy,ring image and data or input file.\n");
    ecmdOutputError("putspyimage - Type 'putspyimage -h' for usage.\n");
    return ECMD_INVALID_ARGS;
  }

  //Setup the target that will be used to query the system config
  std::string chipType, chipUnitType;
  ecmdParseChipField(argv[0], chipType, chipUnitType);
  target.chipType = chipType;
  target.chipTypeState = ECMD_TARGET_FIELD_VALID;
  target.cageState = target.nodeState = target.slotState = target.posState = ECMD_TARGET_FIELD_WILDCARD;
  target.chipUnitTypeState = target.chipUnitNumState = target.threadState = ECMD_TARGET_FIELD_UNUSED;

  //get spy name
  std::string spyName = argv[1];
  char * ringImagefile = argv[2];
  ecmdDataBuffer ringImage;
  // Check if the user specified ring image format is correct
  if(ringformat == "a" )
  {
     // Your input is ASCII and hence reading it as ASCII Format
     rc = ringImage.readFile(ringImagefile, ECMD_SAVE_FORMAT_ASCII);
  }
  else if(ringformat == "b")
  {
     // User Input is Binary
     // Checking if it is  ASCII
     // if the image is ASCII, we error out
     // If it is not ASCII, we go ahead and read it as BINARY Format.
     rc = ringImage.readFile(ringImagefile, ECMD_SAVE_FORMAT_ASCII);
     if(!rc)
     {
       ecmdOutputError("putspyimage - invalid ring image format.\n");
       ecmdOutputError("putspyimage - Type 'getspyimage -h' for usage.\n");
       rc = ECMD_DBUF_INVALID_DATA_FORMAT;
     }
     else
       rc = ringImage.readFile(ringImagefile, ECMD_SAVE_FORMAT_BINARY_DATA);
  }
  else
  {
     ecmdOutputError("putspyimage - Invalid ring image format.\n");
     ecmdOutputError("putspyimage - Type 'getspyimage -h' for usage.\n");
     rc =  ECMD_INVALID_ARGS;
  }
  if(rc) return rc;

  /************************************************************************/
  /* Kickoff Looping Stuff                                                */
  /************************************************************************/

  rc = ecmdLooperInit(target, ECMD_SELECTED_TARGETS_LOOP, looperData);
  if (rc) return rc;
  while (ecmdLooperNext(target, looperData) && (!coeRc || coeMode)) {
  /* Ok, we need to find out what type of spy we are dealing with here, to find out how to output */
    rc = ecmdQuerySpy(target, spyDataList, spyName.c_str(), ECMD_QUERY_DETAIL_LOW);
    if (rc || spyDataList.empty()) {
      printed = "putspyimage - Error occured looking up data on spy " + spyName + " on ";
      printed += ecmdWriteTarget(target) + "\n";
      ecmdOutputError( printed.c_str() );
      coeRc = rc;
      continue;
    }

    spyData = spyDataList.begin();
    if (spyData->isEnumerated) {
      if (inputformat == "default") inputformat = "enum";
    } else {
      if (inputformat == "default") inputformat = "x";
    }

    /* Now that we know whether it is enumerated or not, we can finally finish our arg parsing */
    if (inputformat != "enum") {
           rc = ecmdReadDataFormatted(buffer, argv[3], inputformat, spyData->bitLength);
        if (rc) {
          ecmdOutputError("putspyimage - Problems occurred parsing input data, must be an invalid format\n");
          break;
        }
    }
    /* Setup our chipUnit looper if needed */
    cuTarget = target;
 if (spyData->isChipUnitRelated) {
      /* Error check the chipUnit returned */
      if (!spyData->isChipUnitMatch(chipUnitType)) {
        printed = "putspyimage - Provided chipUnit \"";
        printed += chipUnitType;
        printed += "\"doesn't match chipUnit returned by querySpy \"";
        printed += spyData->relatedChipUnit + "\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
      /* If we have a chipUnit, set the state fields properly */
      if (chipUnitType != "") {
        cuTarget.chipUnitType = chipUnitType;
        cuTarget.chipUnitTypeState = ECMD_TARGET_FIELD_VALID;
      }
      cuTarget.chipUnitNumState = ECMD_TARGET_FIELD_WILDCARD;
      cuTarget.threadState = ECMD_TARGET_FIELD_UNUSED;

      /* Init the chipUnit loop */
      rc = ecmdLooperInit(cuTarget, ECMD_SELECTED_TARGETS_LOOP, cuLooper);
      if (rc) break;
    } else { // !spyData->isChipUnitRelated
      if (chipUnitType != "") {
        printed = "putspyimage - A chipUnit \"";
        printed += chipUnitType;
        printed += "\" was given on a non chipUnit spy\n";
        ecmdOutputError(printed.c_str());
        rc = ECMD_INVALID_ARGS;
        break;
      }
 // Setup the variable oneLoop variable for this non-chipUnit case
      oneLoop = 1;
    }
/* If this isn't a chipUnit spy we will fall into while loop and break at the end, if it is we will call run through configloopernext */
    while ((spyData->isChipUnitRelated ? ecmdLooperNext(cuTarget, cuLooper) : (oneLoop--)) && (!coeRc || coeMode)) {
        if (inputformat == "enum") {
          rc = putSpyEnumImage(cuTarget, spyName.c_str(),argv[3], ringImage );
        } else {
        rc = putSpyImage(cuTarget, spyName.c_str(),buffer, ringImage);
        }
        if (rc) {
          if (rc == ECMD_MULTIPLE_RING_IMAGE_SPY)
          {
              printed = "putspyimage - Command line support for multiple ring images is not supported.  You must use the APIs.\n";
          }
          else
          {
              printed = "putspyimage - Error occured performing putspyimage on ";
              printed += ecmdWriteTarget(cuTarget) + "\n";
          }
          ecmdOutputError( printed.c_str() );
          coeRc = rc;
          continue;
        } else {
          if(ringformat== "a" )
          {
            rc = ringImage.writeFile(argv[2], ECMD_SAVE_FORMAT_ASCII);
          }
          else if(ringformat == "b")
          {
            rc = ringImage.writeFile(argv[2], ECMD_SAVE_FORMAT_BINARY_DATA);
          }
          if(rc) return rc;
          validPosFound = true;
        }
        if (!ecmdGetGlobalVar(ECMD_GLOBALVAR_QUIETMODE)) {
          printed = ecmdWriteTarget(cuTarget) + "\n";
          ecmdOutput(printed.c_str());
        }
     } /* End cuLooper */
 } /* End poslooper */
  // coeRc will be the return code from in the loop, coe mode or not.
  if (coeRc) return coeRc;

  if (!validPosFound && !rc) {
    ecmdOutputError("putspyimage - Unable to find a valid chip to execute command on\n");
    return ECMD_TARGET_NOT_CONFIGURED;
  }
  return rc;
}

#endif // ECMD_REMOVE_SPY_FUNCTIONS

